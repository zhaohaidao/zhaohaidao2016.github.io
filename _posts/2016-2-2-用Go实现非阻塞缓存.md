---
layout: post
title: "用go实现非阻塞缓存"
author: zhaohaiyuan
---
##缓存函数
调用函数访问`map[string]string`时，`保证只计算一次`，其他调用直接返回计算结果
，下面分别是借助锁和通信的实现方案，这两种方案说不上哪种更好，有时候从一种切换至另一种也许能使你的代码更简洁
- - -
### 获取一次锁
互斥锁会导致并发操作完全`串行化`

```go
func (memo *Memo) Get(key string) (value interface{}, err error) {
    res, ok := memo.cache[key] 
    if !ok {
    res.value, res.err = memo.f(key)
    memo.cache[key] = res
    memo.mu.Lock()
    res, ok := memo.cache[key]
    if !ok {
        res.value, res.err = memo.f(key)
        memo.cache[key] = res
    }
    memo.mu.Unlock()
    return res.value, res.err
}
```
### 获取两次锁
查找阶段获取一次，如果查找为空，进入更新阶段再次获取锁，但是这样不能保证`只计算一次`，很有可能两个并发请求访问相同的key,会相互覆盖各种计算的结果

```go
func (memo *Memo) Get(key string) (value interface{}, err error) {
    memo.mu.Lock()
    res, ok := memo.cache[key]
    memo.mu.Unlock()
    if !ok {
        res.value, res.err = memo.f(key)

        // Between the two critical sections, several goroutines
        // may race to compute f(key) and update the map.
        memo.mu.Lock()
        memo.cache[key] = res
        memo.mu.Unlock()
    }
    return res.value, res.err
}
```
### 锁结合通道(channel)：
- 首先获取到锁的goroutine，将channel赋值对map[key]，然后释放锁
- 其他请求得到map[key]非空后，读取channel就会阻塞在该channel上
- 负责更新的goroutine完成计算后，关闭该channel，实现对其他goroutine的广播，此时其他goroutine读就可以读取缓存结果了

```go
	type entry struct {
	    res   result
		ready chan struct{} // closed when res is ready
	}
	
	func New(f Func) *Memo {
	    return &Memo{f: f, cache: make(map[string]*entry)}
	}
	
	type Memo struct {
	    f     Func
		mu    sync.Mutex // guards cache
		cache map[string]*entry
	}
	
	func (memo *Memo) Get(key string) (value interface{}, err error) {
	    memo.mu.Lock()
		e := memo.cache[key]
		if e == nil {
		    // This is the first request for this key.
		    // This goroutine becomes responsible for computing
		    // the value and broadcasting the ready condition.
		    e = &entry{ready: make(chan struct{})}
		    memo.cache[key] = e
			memo.mu.Unlock()
	
			e.res.value, e.res.err = memo.f(key)
	
			close(e.ready) // broadcast ready condition
		} else {
		    // This is a repeat request for this key.
		    memo.mu.Unlock()
	
			<-e.ready // wait for ready condition
		}
		return e.res.value, e.res.err
	}
```
		
### 通信：
- entry的声明和之前保持一致
- 新增叫做requests的channel，Get的调用方用这个channel来和monitor goroutine(go server)来通信
- cache变量被限制在了monitor goroutine (*Memo).server中
- 第一个对某个key的请求负责调用f，保存结果，关闭ready channel实现广播
- call和deliver都需要新起goroutine执行，以免阻塞monitor goroutine
- deliever：其他同一个key的请求发现map[key]!=nil，就会等待结果变成ready，并将response发送给客户端
	 
```go
	// A request is a message requesting that the Func be applied to key.
	type request struct {
	    key      string
		response chan<- result // the client wants a single result
	}
	
	type Memo struct{ requests chan request }
	// New returns a memoization of f.  Clients must subsequently call Close.
	func New(f Func) *Memo {
	memo := &Memo{requests: make(chan request)}
	      go memo.server(f)
		  return memo
	}
	
	func (memo *Memo) Get(key string) (interface{}, error) {
	response := make(chan result)
		      memo.requests <- request{key, response}
	res := <-response
		 return res.value, res.err
	}
	
	func (memo *Memo) Close() { close(memo.requests) }
	func (memo *Memo) server(f Func) {
	cache := make(map[string]*entry)
		   for req := range memo.requests {
	e := cache[req.key]
	   if e == nil {
	       // This is the first request for this key.
	       e = &entry{ready: make(chan struct{})}
	       cache[req.key] = e
		   go e.call(f, req.key) // call f(key)
	   }
	   go e.deliver(req.response)
		   }
	}
	
	func (e *entry) call(f Func, key string) {
	    // Evaluate the function.
	    e.res.value, e.res.err = f(key)
		// Broadcast the ready condition.
		close(e.ready)
	}
	
	func (e *entry) deliver(response chan<- result) {
	    // Wait for the ready condition.
	    <-e.ready
		// Send the result to the client.
		response <- e.res
	}
```
		
		
		
		
